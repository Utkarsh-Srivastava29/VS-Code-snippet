1.In articulation point if the node is 1 and the number of children >1 and then it must be counted within the not visited condition or the number of children must be updated in the not visited and not for the visited case
2.In case of longest flight routes,we need to bfs based topo sort and update dp[1]=1 and then for the children we need to check if dp[src]!=-1 and dp[src]+1>dp[child] then we will update in this condition only because it is possible that dp[src]==-1 and is not reachable from the src node and then we need to take care of the fact that the graph does not contain the cycle and for that the toposort must contain n nodes and also dp[n]==-1 that means if this is not reachable at the moment then also it is impossible.
3.https://www.spoj.com/problems/PT07X/
        #include<bits/stdc++.h>
        using namespace std;
        #define int long long
        void dfs(int src,int par,vector<vector<int>>&g,vector<vector<int>>&dp){
        //agr hum is node ko le lein
        dp[src][0]=1;
        //agr hum is node ko na lein
        dp[src][1]=0;
        for(auto &child:g[src]){
         if(child==par) continue;
         dfs(child,src,g,dp);
         dp[src][0]+=min(dp[child][0],dp[child][1]);
          dp[src][1]+=dp[child][0];
       }
   }
int32_t main(){
   int n;
   cin>>n;
   vector<vector<int>>g(n+1);
   for(int i=0;i<n-1;i++){
       int x,y;
       cin>>x>>y;
       g[x].push_back(y);
       g[y].push_back(x);
   }
   vector<vector<int>>dp(n+1,vector<int>(2,0));
   //undirected graph hai lekin global maximum ya global minimum chahiye then it is same for all the other nodes we can hang it easliy
   dfs(1,0,g,dp);
   cout<<min(dp[1][0],dp[1][1])<<"\n";
}



4.https://codeforces.com/contest/1324/problem/F
  #include<bits/stdc++.h>
using namespace std;
#define int long long
void dfs1(int src,int par,vector<vector<int>>&g,vector<int>&dp,vector<int>&value){
    dp[src]=(value[src]==0)?-1:1;
    for(auto &child:g[src]){
       if(child==par) continue;
       dfs1(child,src,g,dp,value);
       //always take the positive value of the above and nothing else and that will result in the subgraph
       dp[src]+=max(0LL,dp[child]);
    }
}
void dfs2(int src,int par,int value,vector<vector<int>>&g,vector<int>&answer,vector<int>&dp){
       answer[src]=value;
    //    cout<<src<<" "<<value<<"\n";
       for(auto &child:g[src]){
        if(child==par) continue;
        //yahan se neeche jaa rhe hain then we can find the answer for the following
        dfs2(child,src,max(0LL,value-max(0LL,dp[child]))+dp[child],g,answer,dp);
       }
}
int32_t main(){

     int n;
     cin>>n;
     vector<vector<int>>g(n+1);
     vector<int>value(n+1);
     for(int i=1;i<=n;i++) cin>>value[i];
     for(int i=0;i<n-1;i++){
       int x,y;
       cin>>x>>y;
       g[x].push_back(y);
       g[y].push_back(x);
     }
    vector<int>dp(n+1);
    dfs1(1,0,g,dp,value);
    vector<int>answer(n+1);
    dfs2(1,0,dp[1],g,answer,dp);
    for(int i=1;i<=n;i++) cout<<answer[i]<<" ";
  
}

4.https://cses.fi/problemset/task/1673/
High score question mein pooocha gya hai ki agr hum node 1 se start karein to kya hum n tak pahunch jayenge maximum score ke saath and if the score is increased and becomes infinte starting from 1 and till the n then we wil say that it will just increase to infinite
to ek kaam kr skte hain that we first run n-1 times the M edges taaki har edge trigger ho jaaye for its updation and all of the people who are just n-1 edges can be triggered and which are reachable from 1 will be triggered because each time it will cost the value to be increased
and then finally do n relaxations like 1->2->1 with edge weight -1,-1 and then 2->3->4->5->6 so for updating 6 we need to do n updates again in the worst case
and then 
