1.In articulation point if the node is 1 and the number of children >1 and then it must be counted within the not visited condition or the number of children must be updated in the not visited and not for the visited case
2.In case of longest flight routes,we need to bfs based topo sort and update dp[1]=1 and then for the children we need to check if dp[src]!=-1 and dp[src]+1>dp[child] then we will update in this condition only because it is possible that dp[src]==-1 and is not reachable from the src node and then we need to take care of the fact that the graph does not contain the cycle and for that the toposort must contain n nodes and also dp[n]==-1 that means if this is not reachable at the moment then also it is impossible.
3.https://www.spoj.com/problems/PT07X/
        #include<bits/stdc++.h>
        using namespace std;
        #define int long long
        void dfs(int src,int par,vector<vector<int>>&g,vector<vector<int>>&dp){
        //agr hum is node ko le lein
        dp[src][0]=1;
        //agr hum is node ko na lein
        dp[src][1]=0;
        for(auto &child:g[src]){
         if(child==par) continue;
         dfs(child,src,g,dp);
         dp[src][0]+=min(dp[child][0],dp[child][1]);
          dp[src][1]+=dp[child][0];
       }
   }
int32_t main(){
   int n;
   cin>>n;
   vector<vector<int>>g(n+1);
   for(int i=0;i<n-1;i++){
       int x,y;
       cin>>x>>y;
       g[x].push_back(y);
       g[y].push_back(x);
   }
   vector<vector<int>>dp(n+1,vector<int>(2,0));
   //undirected graph hai lekin global maximum ya global minimum chahiye then it is same for all the other nodes we can hang it easliy
   dfs(1,0,g,dp);
   cout<<min(dp[1][0],dp[1][1])<<"\n";
}



4.https://codeforces.com/contest/1324/problem/F
  #include<bits/stdc++.h>
using namespace std;
#define int long long
void dfs1(int src,int par,vector<vector<int>>&g,vector<int>&dp,vector<int>&value){
    dp[src]=(value[src]==0)?-1:1;
    for(auto &child:g[src]){
       if(child==par) continue;
       dfs1(child,src,g,dp,value);
       //always take the positive value of the above and nothing else and that will result in the subgraph
       dp[src]+=max(0LL,dp[child]);
    }
}
void dfs2(int src,int par,int value,vector<vector<int>>&g,vector<int>&answer,vector<int>&dp){
       answer[src]=value;
    //    cout<<src<<" "<<value<<"\n";
       for(auto &child:g[src]){
        if(child==par) continue;
        //yahan se neeche jaa rhe hain then we can find the answer for the following
        dfs2(child,src,max(0LL,value-max(0LL,dp[child]))+dp[child],g,answer,dp);
       }
}
int32_t main(){

     int n;
     cin>>n;
     vector<vector<int>>g(n+1);
     vector<int>value(n+1);
     for(int i=1;i<=n;i++) cin>>value[i];
     for(int i=0;i<n-1;i++){
       int x,y;
       cin>>x>>y;
       g[x].push_back(y);
       g[y].push_back(x);
     }
    vector<int>dp(n+1);
    dfs1(1,0,g,dp,value);
    vector<int>answer(n+1);
    dfs2(1,0,dp[1],g,answer,dp);
    for(int i=1;i<=n;i++) cout<<answer[i]<<" ";
  
}






4.https://cses.fi/problemset/task/1673/
//yahan pe n-1 and then n baar chalana hi pdega and reachability check krna pdega
High score question mein pooocha gya hai ki agr hum node 1 se start karein to kya hum n tak pahunch jayenge maximum score ke saath and if the score is increased and becomes infinte starting from 1 and till the n then we wil say that it will just increase to infinite
to ek kaam kr skte hain that we first run n-1 times the M edges taaki har edge trigger ho jaaye for its updation and all of the people who are just n-1 edges can be triggered and which are reachable from 1 will be triggered because each time it will cost the value to be increased.Pehli baar 1 se koi aur node and then us node se aage ya fir 1 se doosri node and then so on so all the nodes will be updated finally.
and then finally do n relaxations like 1->2->1 with edge weight -1,-1 and then 2->3->4->5->6 so for updating 6 we need to do n updates again in the worst case
and then the final value can be found easily
#include<bits/stdc++.h>
using namespace std;
#define int long long
int32_t main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m;
    cin>>n>>m;
    vector<array<int,3>>g;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        g.push_back({x,y,-z});
    }
    vector<int>dp(n+1,1e18);
    dp[1]=0;
    for(int i=0;i<n-1;i++){
        for(int j=0;j<g.size();j++){
            int x=g[j][0];
            int y=g[j][1];
            int w=g[j][2];
            if(dp[x]<1e18 and dp[y]>dp[x]+w){
                dp[y]=dp[x]+w;
            }
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<g.size();j++){
            int x=g[j][0];
            int y=g[j][1];
            int w=g[j][2];
            if(dp[x]<1e18 and dp[y]>dp[x]+w){
                dp[y]=-1e18;
            }
        }
    }
    if(dp[n]==-1e18) cout<<"-1"<<"\n";
    else cout<<-dp[n]<<"\n";
}










5.https://cses.fi/problemset/task/1673/
#include<bits/stdc++.h>
using namespace std;
#define int long long
int32_t main(){
    int n,m;
    cin>>n>>m;
    //cycle finding mein hum log negative cycle nikalenge at once
    //last waale round mein koi bhi update ho jaaaye to hamara kaam ho jayega
    vector<array<int,3>>edges;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        edges.push_back({x,y,z});
    }
    //n-1 baar chalane ke baad ek baar aur chalake dekh skte hain and at the end jo last node hai wo unvisited rhega
    int k=-1;
    //minimum lena hai
    vector<int>dp(n+1,1e18);
    dp[1]=0;
    vector<int>parent(n+1,-1);
    for(int i=0;i<n;i++){
       k=-1;
       for(int j=0;j<m;j++){
          if(dp[edges[j][0]]+edges[j][2]<dp[edges[j][1]]){
            dp[edges[j][1]]=dp[edges[j][0]]+edges[j][2];
            parent[edges[j][1]]=edges[j][0];
            k=edges[j][1];
          }
       }
    }
    if(k==-1){
        cout<<"NO"<<"\n";
        return 0;
    }
    //humlog n baar krke 1->2(-1) 2->1(-1) 2->3->4->5->6
    for(int i=0;i<n;i++){
        k=parent[k];
    }
    int curr=k;
    vector<int>ans;
    ans.push_back(curr);
    curr=parent[curr];
    while(curr!=k){
        ans.push_back(curr);
        curr=parent[curr];
    }
    ans.push_back(curr);
    //reverse krna zaroori hai kyunki hum kbhi bhi 1->2->3->1 and we will have to 3->2->1->3 will not form he cycle
    reverse(ans.begin(),ans.end());
    cout<<"YES"<<"\n";
    for(auto &x:ans) cout<<x<<" ";
}
