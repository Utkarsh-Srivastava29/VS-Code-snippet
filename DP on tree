
-->DP rerooting->time complexity->O(n)-->Finding something for all the roots.No recomputation, no wasted work.Time: O(n) total.Space: O(n)
                                      -->Rerooting = down DP + parent contribution, done once each â†’ efficient answers for all nodes.
                                      -->First do a down pass to compute subtree answers, then an up pass to add parent contributions, giving the correct answer for every node as root.
                                      -->If the root is fixed and the task is only to collect values from subtrees (sum / count / size) with no choices (max/min), then one DFS is enoughâ€”compute subtree values bottom-up and youâ€™re done.
                                      -->For rerooting, compute the contribution of u excluding child v as down[u] âˆ’ down[v].Trick: compute prefix and suffix products or sums of children's contributions.This allows excluding any child in O(1) time, keeping the up pass linear (O(n)).
                                      -->You canâ€™t use down[u] directly because it already includes the contribution of child v.
                                      -->Rerooting DP uses a down pass and an up pass, with prefix/suffix tricks to exclude one child in O(1), turning all-roots problems from O(nÂ²) into O(n).

                                         function reroot(tree)//O(n) for data
                                           dfs_down(1,-1)
                                           dfs_up(1,-1,0)
                                           for each node v
                                             answer[v]:=combine(dp_down[v],dp_up[u])
                                           
                                      -->Both methods are O(n); BFS is often simpler to code, while DP gives deeper structural insight into trees.The diameter either appears as the longest path from a farthest node (BFS view) or as the sum of two deepest branches meeting at some node (DP view).
                                      -->down[v] = Î£ ( down[u] + size[u] )   for all children u.size[v] = 1 + Î£ size[u].+ size[u] â†’ har node 1 edge aur door ho gaya (v â†’ u).down[u] â†’ u ke subtree ke andar distances
                                      -->Ab har node ko root banane ka effect propagate karna hai.
                                      -->up[u] =
                                                 ( up[v] + down[v] )           // sab upar se
                                               - ( down[u] + size[u] )         // u ke subtree ko hatao
                                               + ( n - size[u] )               // baaki nodes 1 edge aur door
                                      -->Down = subtree info.Up = rest of tree info.Answer = combine both
                                      -->Tree Matching = Parent edge state DP.Is this node already used by parent or free?
                                      -->dp[u][0] = max matching in subtree of u when u is NOT matched with its parent
                                      -->dp[u][1] = max matching in subtree of u when u IS matched with its parent
                                                    --->dp[u][1] (u matched with parent),dp[u][1] = Î£ dp[child][0]
                                                    --->dp[u][0] (u NOT matched with parent),  u kisi child se match na kare->(base = Î£ max(dp[child][0], dp[child][1]))  ,  
                                                                                               u kisi ek child se match kr jae->candidate =  1   +   dp[v][1] +  Î£ (for other children c â‰  v) max(dp[c][0], dp[c][1])
                                     --->final answer  dp[u][0] = max(base, all candidates),answer = max(dp[root][0], dp[root][1])
                                     --->How to know that the problem is asking about the rerooting?compute X for all possible roots.X could be sum of distances, maximum path length, number of good subtrees, diameter, etc.
                                     ---> Rerooting works if the answer at each node ð‘£ can be cleanly split into a subtree contribution down[v] and an outside-of-subtree contribution up[v], with both defined consistently.If this decomposition exists, rerooting works.
                                     --->If we are given a tree and we are given a directed tree and we are asked to reverse some edges for each of the nodes and tell how many edges need to be reversed for a particular node then we can use the correct direction as 0 and the reverse direction as 1 and make an undirected graph for the same and then while going from the node to its child we need to see this particular edge only and that is it about the above.
                                     --->Distance sum,ans[v] = ans[u] + n - 2 * subtree[v]
                                     --->Directed edge reversal
                                         if u -> v:
                                             cost[v] = cost[u] + 1
                                         else:
                                             cost[v] = cost[u] - 1
                                    --->Prefixâ€“suffix for children,siblings = combine(pref[i-1], suff[i+1]),pref[i]=combine(down[c1â€‹],down[c2â€‹],â€¦,down[ciâ€‹]),suff[i]=combine(down[ciâ€‹],down[ci+1â€‹],â€¦,down[ckâ€‹]),combine(pref[iâˆ’1], suff[i+1])
                                    --->This prefix suffix rule works for sum,min,max,gcd,or/and,not for subtraction,divison and string concatenation,up[ci] = combine(up[u], combine(pref[i-1], suff[i+1]))
                                    --->dfs1(u, p): node 1 ko root maan kar initial backward edges count.dfs2(u, p): parent se child ko reroot karte hue upar wale rule se cost adjust.Edge direction ke basis par constant time update â†’ poora rerooting O(n) me ho jata hai.Use when: Directed tree me har node ke liye â€œminimum reversals / cost if this node is rootâ€ type problems.
                                    --->Reroot transition (u â†’ v):Agar edge u â†’ v hai: root v banane par cost +1.Agar edge v â†’ u hai: root v banane par cost âˆ’1.
                                    --->Rerooting likhne ke baad hamesha n = 1 aur n = 2 manually check karo.Agar yahan fail hua, bada input bhi galat hoga.
                                    --->If your combine is simple â†’ 2 passes.If you need multiple best values or dynamic updates â†’ extra passes / advanced tools.
                                    --->https://codeforces.com/problemset/problem/1324/F
                                    --->For the above question which is one lne above if up[u]>0 include it.ans[u]=color[u]+sum(max(0,dp[child])+max(0,up[u])).Sometimes we need to ignore some value
                                    --->Common mistakes in the above(Rerooting)
                                        Before submitting rerooting solution, mentally check:
                                        1.child ka contribution up[v] me exclude hua?
                                        2.weighted edges me w * size use hua?
                                        3.up[root] = 0 properly set?
                                        4.max(0, â€¦) lagaya jahan subtree optional hai?
                                    --->The hard part is setting up the DP state and combine function correctly, not the two-pass structure itself.
                                    Jab bhi lage:
                                    â€œsirf ek value kaafi nahi haiâ€
                                     turant DP state ko struct bana do.
 
                                     pattern same

                                     DFS passes same

                                     sirf state heavy ho jaata hai
                   
                                     down[u] = { field1, field2, ... }
                                     up[u]   = { field1, field2, ... }
                                      struct State {
                                          long long cnt;
                                          long long sum;
                                       };
                                     --->Rerooting is not dynamic.Tree badla â‡’ technique badlo.You need dynamic tree data structures like Link-Cut Trees or Euler Tour Trees.If only node values change but the structure stays fixed, you might be able to use rerooting combined with segment trees or other range query structures.



                                                     



//Most of the problems of subtree dp can be solved using the subtree size approach or the incude exclude approach and that is it for the subtree dp
-->Subtree DP(for choices max,min etc and the tree is rooted)-->choosing options like max/min with choices(max/min,matching,independent set,vertex cover)
                Tree DP = Post-order DFS + child answers ko combine karo.Agar state clearly define ho aur child answers sahi tarah combine ho jaayein, to counting, maximization, path sums aur matching jaise complex problems naturally solve ho jaate hain.
                Tree = recursive structure â†’ children pehle solve karo, phir parent ka answer banao.
                Form:dp[u]=f(dp[child1â€‹],dp[child2â€‹],â€¦)
                Why it works:
                Trees have no cycles, so each node depends only on its descendants.
                Tree = ek direction me flow (neeche â†’ upar)
                DP = neeche se upar answers combine karna
                Cycle nahi â‡’ circular dependency nahi â‡’ DP safe
                u â†’ v
                â†‘   â†“
                â† â† â†
                Upar waale mein agr mein dp[u] ki value chahiye then we must have the value of the dp[v] and this will just result into the final result and the value.
                dp[u] chahiye dp[v]
                dp[v] chahiye dp[u]
                infinite loop
                DP impossible (jab tak special algo na lagao)
                --->Kya problem ka answer â€œpure treeâ€ se related hai and how do we know that the answer do not depend on the parent and only on the subtree?
                    â€œin subtreeâ€, â€œbelowâ€, â€œdownwardâ€ â†’ subtree DP
                     â€œany nodeâ€, â€œwhole treeâ€, â€œglobalâ€ â†’ subtree DP not enough
                --->agr parent p bhi hamara answer depend krta hai then we need to have dp rerooting and for that we need two pass dp.
                    Jab har node ka answer â€œpoore treeâ€ se related ho,aur subtree DP incomplete ho jaaye,tab rerooting DP use karte hain.
                    agar parent ki taraf dekhna pade â†’ rerooting DP (most of the time)


                    Subtree dp important concepts:-
                    1.subtree
                    2.descendants
                    3.below node
                    4.rooted tree
                    5.downward paths
                    6.within the subtree

                    Only subtree info needed   Subtree DP
                    Whole tree info per node   Rerooting DP
                    Single root answer         Normal DFS
                    All nodes as root          Rerooting DP

                    Use post order processing and this ensures you have all child results before computing parent's result.
                    function dfs(u,parent)
                         for each child in v of u
                           if(v!=parent) then
                               dfs(v,u)
                                 //process u using results from the children
                               compute dp[u] from dp[children]
                     The bottom-up flow is the essence of the subtree dp
                      -->Subtree DP = post-order DFS + children ke answers jodna
                      -->void dfs(int u, int p) {
                              sz[u] = 1;                  // count yourself
                              for (int v : g[u]) {
                              if (v == p) continue;
                              dfs(v, u);
                              sz[u] += sz[v];         // add child subtree
                             }
                         }

                      -->Subtree size = 1 + sum of childrenâ€™s subtree sizes, computed using post-order DFS.

                      -->pehle clearly define karo ki dp[v] ka matlab kya hai.
                         dp[v] = number of nodes in subtree rooted at v
                         dp[v] = maximum path sum starting from v going down
                         dp[v] = true/false if subtree of v satisfies condition
                         dp[v] = combine(dp[child1], dp[child2], ..., dp[childk])

                      -->Tree DP = define dp[v] clearly + post-order DFS + combine child dp values


                      -->Tree DP = DFS + har node ek baar + har edge do baar â‡’ O(n).Grid DP me same subproblem baar-baar aata hai.Therefore Tree DP is fast.
                      -->Unrooted tree â†’ pick any root â†’ do subtree DP; root matters only if the problem is directional.
                      -->run dfs from root(node 1).For each node,visit children first,then compute subtree sizes 
                         function dfs(u,parent)
                             size[u]:=1
                             for each child in v of u
                                if(v!=parent) then
                                   dfs(v,u)
                                   size[u]:=size[u]+size[v] 
                      -->Tree DP is just: define dp â†’ DFS children â†’ combine answers.This problem shows the core pattern: define state (subtree size), write recurrence (sum children plus self), implement DFS. Many tree DP problems follow this exact structure. The only difference is what you aggregate (size, max, count, etc.).
                      -->Jab tree problem mein har node par include/exclude ka decision ho aur wo decision children ko affect kare, tab 2-state Include/Exclude DP use hota hai.Agr 2 adjacent log ko nahin le skte hain
                      -->If you include v,you cannot icnlude its children and therefore dp[v][1]=value+dp[child][0] for all children,else if we exclude node v,each child can be included or excluded independently.dp[v][0]=sum of max(dp[child][0],dp[child][1]) for all children.
                      Question time:-
                           Q->you are a robber planning to rob houses arranged in a binary tree. Each house has a value stored at its node. If you rob two directly-linked houses (parent and child), the alarm triggers and you get caught. Find the maximum value you can rob without triggering the alarm?
                           Solution->This is the classic include/exclude pattern on trees.The constraint (no adjacent nodes) determines the recurrence.
                           dp[v][0]-->maximum value you can rob from subtree rooted at v if you don't rob the house v.
                           dp[v][1]-->maximum value you can rob from subtree rooted at v if I do rob at the house v.
                           







                          //In the following question we can take any root and the proof is that if the answer is minimum for root S1 then first assign according to S1 and then hang the tree using the other node so in this way the answer is always possible from every root.
                         //Minimum number of lamps required to be lit so that whole tree gets lit and a lamp can lit upto distance 1 only
                      -->#include <bits/stdc++.h>
                         using namespace std;

                         const long long INF = 1e18;
                         vector<vector<int>> g;
                         vector<array<long long, 3>> dp;

                         void dfs(int u, int p) {
                         dp[u][0] = 1;     // lamp at u
                         dp[u][1] = 0;     // covered, no lamp
                         dp[u][2] = 0;     // not covered

                         long long extra = INF;
                         bool hasLampChild = false;

                         for (int v : g[u]) {
                           if (v == p) continue;
                           dfs(v, u);

                           // Case 0: lamp at u
                           dp[u][0] += min({dp[v][0], dp[v][1], dp[v][2]});

                           // Case 2: u not covered â†’ children must be covered without lamp
                           dp[u][2] += dp[v][1];

                           // Case 1: u covered by children
                           dp[u][1] += min(dp[v][0], dp[v][1]);

                           // Track forcing at least one child to have lamp
                            extra = min(extra, dp[v][0] - min(dp[v][0], dp[v][1]));
                            if (dp[v][0] <= dp[v][1]) hasLampChild = true;
                          }
 
                          if (!hasLampChild)
                          dp[u][1] += extra;
                       }
 
                       int main() {
                       ios::sync_with_stdio(false);
                       cin.tie(nullptr);

                       int n;
                       cin >> n;

                       g.assign(n + 1, {});
                       dp.assign(n + 1, {0, 0, 0});

                       for (int i = 0; i < n - 1; i++) {
                       int u, v;
                       cin >> u >> v;
                       g[u].push_back(v);
                       g[v].push_back(u);
                      }

                      dfs(1, 0);

                      cout << min(dp[1][0], dp[1][1]) << "\n";
                      return 0;
                     }









-->Traversal-->collect data(size,sum,depth)

-->Diameter-->find the longest path
              
-->Distance sum from node 1 = subtree DP. Distance sum for all nodes = rerooting.





